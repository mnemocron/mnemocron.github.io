---
layout: post
title: 7400 FPGA diary 5 - Hello World
subtitle: program single bits in the bitstream
gh-repo: mnemocron/my-discrete-fpga
gh-badge: [star, follow]
tags: [diy-fpga]
comments: true
---

Since the completion of the most complicated modular PCB module, the CLB, I have successfully assembled the surrounding interconnect PCBs.
As it turns out, you _can_ reflow solder PCBs on the stove in your kitchen.
In unrelated news, does anybody have tips on how to get rid of unwanted smells in your apartment?

In theory, my PCB design should match the previously designed VHDL model. 
In practive, I messed up the byte order on the switchbox PCB (which was a pain to layout precisely because of the byte order).
Other than that, all of the SW, CBh and CBv are working flawlessly as designed.
It is now time to verify previously generated and simulated bitstreams on actual hardware.
But how do you program an FPGA by bitstream directly?


## How to program a 4-bit counter

### 1. Routing

Let's start with the LSB of the counter which behaves like an inverter. 
This signal will have to be routed from the output of the LUT back to one of the four inputs of the LUT.

I am going to pick LUT output `A` or `0` as my LSB.
This bit will leave the CLB on the 4-bit wide bus at position `[0]` and enter the vertical connection box (CBv) on its west input bus.
To enable this signal to the horizontal routing lines the crosspoint `xp_bus[0]` must be enabled by programming a `1` in the bitstream at location `7`.
The signal will now arrive at the south bus of the switch box (SW). To loop it back to the horizontal connection box (CBh) three bits must be set.
Twice to enable the bus signal to enter the crosspoint matrix (`en_bus_south[0]` / `en_bus_west[0]`) and one crosspoint bit `xp_bus[0]`.

Next, the CBh creates the input selection for all the LUTs in the CLB. The default (unprogrammed) value will pick `GND`.
Therefore, a corresponding value must be programmed to select the correct input signal from `bus[0]`.
This is done with three bits named `presel_0[2:0]`.
To select the `bus[0]` line, the multiplexer must be set to input 7 which translates to `presel_0[2:0] = "111"`.

In my Arduino sketch, this would look like this:


char conf_bits[BITS_CONFIGURED] = {
   7,   // CBv: enable LUT_a output
   111, // SW:  xp_bus[0]
   119, // SW:  en_bus_south[0]
   127, // SW:  en_bus_west[0]
   101, // CBh: presel_0[2] --> MUX addr +4
   102, // CBh: presel_0[1] --> MUX addr +2
   103, // CBh: presel_0[0] --> MUX addr +1

### 2. LUT contents

Now that the signal is routed, a behaviour must be defined inside the LUT.



And by the way, you can do this on modern FPGAs too by manually instantiating a LUT primitive and define its contents as a hex vector: [Xilinx UG953](https://docs.xilinx.com/r/en-US/ug953-vivado-7series-libraries/LUT6).


### 3. CLB options



---


![https://mnemocron.github.io/assets/img/fpga-diary-4/pcb-comparison.jpg](https://mnemocron.github.io/assets/img/fpga-diary-4/pcb-comparison.jpg){: .mx-auto.d-block :}
**Fig 1:** _PCB before and after assembly and debugging._

A month or so after sausageing around in KiCad I have some fresh PCBs on my desk ready for prototyping.
(Not for the life of me! did I want to make this a 4-layer PCB even though we live in 2024 and there are virtually no good arguments against 4-layers anymore. anyways.)
The boards look pretty. And yellow. Just like in the drawings I made.

{: .box-note}
_In theory, theory and practice are the same. In practice, they are not._

What I came up with is shown in _Fig. 2_.

